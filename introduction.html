
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>1. Introduction &#8212; Programming in Lean 3.4.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Monads" href="monads.html" />
    <link rel="prev" title="Programming in Lean" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="introduction">
<span id="id1"></span><h1>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">&#182;</a></h1>
<p><em>Warning.</em> This book is still under construction. It aims to serve as
both an introduction and a reference manual for programming in the Lean
theorem prover.</p>
<p>We are making this material public now because currently it is the only
existing documentation for many of the specifics of the Lean programming
language and its API, and we are hoping that the information will be
useful to brave souls experimenting with it at this early stage. Most of
the chapters are currently only stubs, but comments and feedback on the
material that is available will be helpful.</p>
<div class="section" id="lean-as-a-programming-language">
<h2>1.1. Lean as a Programming Language<a class="headerlink" href="#lean-as-a-programming-language" title="Permalink to this headline">&#182;</a></h2>
<p>This book can be viewed as a companion to <a class="reference external" href="https://leanprover.github.io/theorem_proving_in_lean/">Theorem Proving in
Lean</a>, which
presents Lean as a system for building mathematical libraries and
stating and proving mathematical theorems. From that perspective, the
point of Lean is to implement a formal axiomatic framework in which one
can define mathematical objects and reason about them.</p>
<p>As noted in that book, however, expressions in Lean have a computational
interpretation, which is to say, they can be <em>evaluated</em>. As long as it
is defined in the computational fragment of Lean&#8217;s foundational
language, any closed term of type <code class="docutils literal notranslate"><span class="pre">nat</span></code> &#8211; that is, any term of type
<code class="docutils literal notranslate"><span class="pre">nat</span></code> without free variables &#8211; evaluates to a numeral. Similarly, any
closed term of type <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">nat</span></code> evaluates to a list of numerals, and
any closed term of type <code class="docutils literal notranslate"><span class="pre">bool</span></code> evaluates either to the boolean value
<code class="docutils literal notranslate"><span class="pre">tt</span></code>, for &#8220;true,&#8221; or <code class="docutils literal notranslate"><span class="pre">ff</span></code>, for &#8220;false.&#8221;</p>
<p>This provides another perspective on Lean: instead of thinking of it as
a theorem prover whose language just happens to have a computational
interpretation, think of it as a programming language that just happens
to come equipped with a rich specification language and an interactive
environment for proving that programs meet their specifications. The
specification language and proof system are quite powerful, rich enough,
in fact, to include all conventional mathematics.</p>
<p>We will see that Lean&#8217;s underlying logical framework, the Calculus of
Inductive Constructions, constitutes a surprisingly good programming
language. It is expressive enough to define all sorts of data
structures, and it supports powerful abstractions. Programs written in
the language can be evaluated efficiently by Lean&#8217;s virtual-machine
interpreter or translated automatically to C++ and compiled.</p>
<p>Viewed from a computational perspective, the Calculus of Inductive
Constructions is an instance of a purely functional programming
language. This means that a program in Lean is simply an expression
whose value is determined compositionally from the values of the other
expressions it refers to, independent of any sort of ambient state of
computation. There is no notion of storing a result in memory or
changing the value of a global variable; computation is just evaluation
of expressions. This paradigm makes it easier to reason about programs
and verify their correctness. At the same time, we will see that Lean
incorporates concepts and abstractions that make it feasible to use this
paradigm in practice.</p>
<p>The underlying foundational framework imposes one restriction that is
alien to most programming languages, namely, that every program is
terminating. So, for example, every &#8220;while&#8221; loop has to be explicitly
bounded, though, of course, we can consider the result of iterating an
arbitrary computation <code class="docutils literal notranslate"><span class="pre">n</span></code> times for any given natural number <code class="docutils literal notranslate"><span class="pre">n</span></code>. We
will see that Lean provides flexible mechanisms for structural and
well-founded recursion, allowing us to define functions in natural ways.
At the same, the system provides complementary mechanisms for proving
claims, using inductive principles that capture the structure of the
function definitions.</p>
</div>
<div class="section" id="examples">
<h2>1.2. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">&#182;</a></h2>
<p>For example&#8230;</p>
<p>[Define something like factorial. Evaluate (use both <code class="docutils literal notranslate"><span class="pre">reduce</span></code> and
<code class="docutils literal notranslate"><span class="pre">eval</span></code>).]</p>
<p>[Define operations on lists.]</p>
<p>[Prove things, like <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">(reverse</span> <span class="pre">l)</span> <span class="pre">=</span> <span class="pre">length</span> <span class="pre">l</span></code> or <code class="docutils literal notranslate"><span class="pre">reverse</span>
<span class="pre">(reverse</span> <span class="pre">l)</span> <span class="pre">=</span> <span class="pre">l</span></code>.]</p>
</div>
<div class="section" id="input-and-output">
<h2>1.3. Input and Output<a class="headerlink" href="#input-and-output" title="Permalink to this headline">&#182;</a></h2>
<p>People often want to write programs that interact with the outside
world, querying users for input and presenting them with output during
the course of a computation. Lean&#8217;s foundational framework has no model
of &#8220;the real world,&#8221; but Lean declares <code class="docutils literal notranslate"><span class="pre">get_str</span></code> and <code class="docutils literal notranslate"><span class="pre">put_str</span></code>
commands to get an input string from the user and write an input string
to output, respectively. Within the foundational system, these are
treated as black box operations. But when programs are evaluated by
Lean&#8217;s virtual machine or when they are translated to C++, they have the
expected behavior. Here, for example, is a program that prints &#8220;hello
world&#8221;:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20system.io%0Avariable%20%5Bio.interface%5D%0Aopen%20io%0A%0Adef%20hello_world%20:%20io%20unit%20:=%0Aput_str%20%22hello%20world%5Cn%22%0A%0A#eval%20hello_world" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">system.io</span>
<span class="kd">variable</span> <span class="o">[</span><span class="n">io.interface</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">io</span>

<span class="kd">def</span> <span class="n">hello_world</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">put_str</span> <span class="s2">&quot;hello world</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="k">#eval</span> <span class="n">hello_world</span>
</pre></div>
</div>
</div><p>The next example prints the first 100 squares:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20system.io%0Avariable%20%5Bio.interface%5D%0Aopen%20nat%20io%0A%0Adef%20print_squares%20:%20%E2%84%95%20%E2%86%92%20io%20unit%0A%7C%200%20%20%20%20%20%20%20%20:=%20return%20()%0A%7C%20(succ%20n)%20:=%20print_squares%20n%20%3E%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20put_str%20(nat.to_string%20n%20++%20%22%5E2%20=%20%22%20++%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20nat.to_string%20(n%20*%20n)%20++%20%22%5Cn%22)%0A%0A#eval%20print_squares%20100" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">system.io</span>
<span class="kd">variable</span> <span class="o">[</span><span class="n">io.interface</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">io</span>

<span class="kd">def</span> <span class="n">print_squares</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">io</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="n">return</span> <span class="o">()</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">print_squares</span> <span class="n">n</span> <span class="bp">&gt;&gt;</span>
              <span class="n">put_str</span> <span class="o">(</span><span class="n">nat.to_string</span> <span class="n">n</span> <span class="bp">++</span> <span class="s2">&quot;^2 = &quot;</span> <span class="bp">++</span>
                       <span class="n">nat.to_string</span> <span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="bp">++</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">print_squares</span> <span class="mi">100</span>
</pre></div>
</div>
</div><p>We will explain the data type <code class="docutils literal notranslate"><span class="pre">io</span> <span class="pre">unit</span></code> in Chapter
<a class="reference external" href="07_Monads::#Monads">Monads</a>. Although this program has a real world
side effect of sending output to the screen when run, that effect is
invisible to the formal foundation. From the latter&#8217;s perspective, the
type constructor <code class="docutils literal notranslate"><span class="pre">io</span></code> and the functions <code class="docutils literal notranslate"><span class="pre">put_str</span></code> and <code class="docutils literal notranslate"><span class="pre">get_str</span></code>
are entirely opaque, objects about which that the axiomatic system has
nothing to say. The <code class="docutils literal notranslate"><span class="pre">print</span>
<span class="pre">axioms</span></code> command shows that the expression <code class="docutils literal notranslate"><span class="pre">hello</span> <span class="pre">world</span></code> depends on
the constants <code class="docutils literal notranslate"><span class="pre">io</span></code> and <code class="docutils literal notranslate"><span class="pre">put_str</span></code>, which have been forcibly added to
the axiomatic system.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20system.io%0Avariable%20%5Bio.interface%5D%0Aopen%20io%0A%0Adef%20hello_world%20:%20io%20unit%20:=%0Aput_str%20%22hello%20world%5Cn%22%0A%0A--%20BEGIN%0A#print%20axioms%20hello_world%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="k">#print</span> <span class="kd">axioms</span> <span class="n">hello_world</span>
</pre></div>
</div>
</div><p>In this way, we can prove properties of programs involving <code class="docutils literal notranslate"><span class="pre">io</span></code> that
do not depend in any way on the particular results of the input and
output.</p>
</div>
<div class="section" id="metaprogramming-in-lean">
<span id="id2"></span><h2>1.4. Metaprogramming in Lean<a class="headerlink" href="#metaprogramming-in-lean" title="Permalink to this headline">&#182;</a></h2>
<p>Lean also allows <em>metaprograms</em>, which are Lean programs that involve
objects and constructs that are not part of the axiomatic foundation. In
particular:</p>
<ul class="simple">
<li>Metaprograms can use arbitrary recursive calls, with no concern for
termination.</li>
<li>Metaprograms can access <em>metaconstants</em>, that is, primitive functions
and objects that are implemented internally in Lean and are not meant
to be trusted by the foundational framework.</li>
</ul>
<p>Such definitions can be introduced using the keywords <code class="docutils literal notranslate"><span class="pre">meta</span> <span class="pre">def</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">def</span></code> and are marked for special treatment. In particular,
because they are not part of the axiomatic foundation, they cannot
appear as part of ordinary Lean definitions and theorems.</p>
<p>For example, the following definition computes McCarthy&#8217;s 91 function,
without verifying that the computation terminates on all inputs (though,
in fact, it does):</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=meta%20def%20m91%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20n%20:=%20if%20n%20%3E%20100%20then%20n%20-%2010%20else%20m91%20(m91%20(n%20+%2011))%0A%0A#eval%20m91%2010%0A#eval%20m91%20100%0A#eval%20m91%201000" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">m91</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">100</span> <span class="k">then</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">10</span> <span class="k">else</span> <span class="n">m91</span> <span class="o">(</span><span class="n">m91</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">11</span><span class="o">))</span>

<span class="k">#eval</span> <span class="n">m91</span> <span class="mi">10</span>
<span class="k">#eval</span> <span class="n">m91</span> <span class="mi">100</span>
<span class="k">#eval</span> <span class="n">m91</span> <span class="mi">1000</span>
</pre></div>
</div>
</div><p>We can print out the first 120 values of <code class="docutils literal notranslate"><span class="pre">m91</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20system.io%0Avariable%20%5Bio.interface%5D%0Aopen%20nat%20io%0A%0Ameta%20def%20m91%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20n%20:=%20if%20n%20%3E%20100%20then%20n%20-%2010%20else%20m91%20(m91%20(n%20+%2011))%0A%0A--%20BEGIN%0Ameta%20def%20print_m91%20:%20%E2%84%95%20%E2%86%92%20io%20unit%0A%7C%200%20%20%20%20%20%20%20%20:=%20return%20()%0A%7C%20(succ%20n)%20:=%20print_m91%20n%20%3E%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20put_str%20(%22m91%20%22%20++%20nat.to_string%20n%20++%20%22%20=%20%22%20++%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20nat.to_string%20(m91%20n)%20++%20%22%5Cn%22)%0A%0A#eval%20print_m91%20120%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">print_m91</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">io</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="n">return</span> <span class="o">()</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">print_m91</span> <span class="n">n</span> <span class="bp">&gt;&gt;</span>
              <span class="n">put_str</span> <span class="o">(</span><span class="s2">&quot;m91 &quot;</span> <span class="bp">++</span> <span class="n">nat.to_string</span> <span class="n">n</span> <span class="bp">++</span> <span class="s2">&quot; = &quot;</span> <span class="bp">++</span>
                       <span class="n">nat.to_string</span> <span class="o">(</span><span class="n">m91</span> <span class="n">n</span><span class="o">)</span> <span class="bp">++</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">print_m91</span> <span class="mi">120</span>
</pre></div>
</div>
</div><p>Of course, such uses of recursion are dangerous.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=meta%20def%20foo%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20n%20:=%20foo%20n%20+%201%0A%0A#reduce%20foo%0A--%20#eval%20foo%200" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="k">#reduce</span> <span class="n">foo</span>
<span class="c1">-- #eval foo 0</span>
</pre></div>
</div>
</div><p>Evaluating <code class="docutils literal notranslate"><span class="pre">foo</span></code> using the kernel evaluator shows that the
implementation is a bit of a hack; the term in the definition includes a
macro which names <code class="docutils literal notranslate"><span class="pre">foo</span></code> itself. The virtual machine that evaluates foo
goes further, and carries out the recursive call, repeating this until
the process runs out of memory. It is a good thing that Lean will not
allow <code class="docutils literal notranslate"><span class="pre">foo</span></code> to appear in a <code class="docutils literal notranslate"><span class="pre">theorem</span></code> or in an ordinary
<code class="docutils literal notranslate"><span class="pre">definition</span></code>; if we could prove <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">=</span> <span class="pre">foo</span> <span class="pre">+</span> <span class="pre">1</span></code> then, substracting
<code class="docutils literal notranslate"><span class="pre">foo</span></code> from both sides, we could prove <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">=</span> <span class="pre">1</span></code>, and hence a
contradiction.</p>
<p>Although metaprograms can be used in various ways, its primary purpose
is to provide a means of extending the functionality of Lean, within
Lean itself. For example, we can use metaprograms to write new
procedures, known as <em>tactics</em>, which help us construct proofs. This
next example assumes you are familiar with the notion of a tactic, as
described in <em>Theorem Proving in Lean</em>.</p>
<p>The following code implements a tactic that, given any goal, repeatedly
finds a hypothesis <code class="docutils literal notranslate"><span class="pre">h</span></code> of the form <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8743;</span> <span class="pre">b</span></code>, and replaces it by
hypotheses (with fresh names) for <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%20monad%20expr%0A%0A--%20BEGIN%0Ameta%20def%20destruct_conjunctions%20:%20tactic%20unit%20:=%0Arepeat%20(do%0A%20%20l%20%E2%86%90%20local_context,%0A%20%20first%20$%20l%5E.for%20(%CE%BB%20h,%20do%0A%20%20%20%20ht%20%E2%86%90%20infer_type%20h%20%3E%3E=%20whnf,%0A%20%20%20%20match%20ht%20with%0A%20%20%20%20%7C%20%60(and%20%25%25a%20%25%25b)%20:=%20do%0A%20%20%20%20%20%20n%20%E2%86%90%20mk_fresh_name,%0A%20%20%20%20%20%20mk_mapp%20%60%60and.left%20%5Bnone,%20none,%20some%20h%5D%20%3E%3E=%20assertv%20n%20a,%0A%20%20%20%20%20%20n%20%E2%86%90%20mk_fresh_name,%0A%20%20%20%20%20%20mk_mapp%20%60%60and.right%20%5Bnone,%20none,%20some%20h%5D%20%3E%3E=%20assertv%20n%20b,%0A%20%20%20%20%20%20clear%20h%0A%20%20%20%20%7C%20_%20:=%20failed%0A%20%20%20%20end))%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">destruct_conjunctions</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">repeat</span> <span class="o">(</span><span class="k">do</span>
  <span class="n">l</span> <span class="bp">&#8592;</span> <span class="n">local_context</span><span class="o">,</span>
  <span class="n">first</span> <span class="bp">$</span> <span class="n">l</span><span class="bp">^.</span><span class="n">for</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">ht</span> <span class="bp">&#8592;</span> <span class="n">infer_type</span> <span class="n">h</span> <span class="bp">&gt;&gt;=</span> <span class="n">whnf</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">ht</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">and</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
      <span class="n">n</span> <span class="bp">&#8592;</span> <span class="n">mk_fresh_name</span><span class="o">,</span>
      <span class="n">mk_mapp</span> <span class="bp">``</span><span class="n">and.left</span> <span class="o">[</span><span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">some</span> <span class="n">h</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">assertv</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">n</span> <span class="bp">&#8592;</span> <span class="n">mk_fresh_name</span><span class="o">,</span>
      <span class="n">mk_mapp</span> <span class="bp">``</span><span class="n">and.right</span> <span class="o">[</span><span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">some</span> <span class="n">h</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">assertv</span> <span class="n">n</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">clear</span> <span class="n">h</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>
    <span class="kd">end</span><span class="o">))</span>
</pre></div>
</div>
</div><p>We will explain the details in <a class="reference external" href="08_Writing_Tactics.org::#Writing_Tactics">Chapter
8</a> but, roughly speaking,
the code repeats the following action until there is nothing left to do:
get the list of hypotheses in the local context, find a hypothesis <code class="docutils literal notranslate"><span class="pre">h</span></code>
whose type is a conjunction, add new hypotheses justified by <code class="docutils literal notranslate"><span class="pre">and.left</span>
<span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">and.right</span> <span class="pre">h</span></code> to the local context, and then delete <code class="docutils literal notranslate"><span class="pre">h</span></code>. We
can then use <code class="docutils literal notranslate"><span class="pre">destruct_conjunctions</span></code> like any other Lean tactic.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%20monad%20expr%0A%0Ameta%20def%20destruct_conjunctions%20:%20tactic%20unit%20:=%0Arepeat%20(do%0A%20%20l%20%E2%86%90%20local_context,%0A%20%20first%20$%20l%5E.for%20(%CE%BB%20h,%20do%0A%20%20%20%20ht%20%E2%86%90%20infer_type%20h%20%3E%3E=%20whnf,%0A%20%20%20%20match%20ht%20with%0A%20%20%20%20%7C%20%60(and%20%25%25a%20%25%25b)%20:=%20do%0A%20%20%20%20%20%20n%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20%20%20%20mk_mapp%20%60%60and.left%20%5Bnone,%20none,%20some%20h%5D%20%3E%3E=%20assertv%20n%20a,%0A%20%20%20%20%20%20n%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20%20%20%20mk_mapp%20%60%60and.right%20%5Bnone,%20none,%20some%20h%5D%20%3E%3E=%20assertv%20n%20b,%0A%20%20%20%20%20%20clear%20h%0A%20%20%20%20%7C%20_%20:=%20failed%0A%20%20%20%20end))%0A%0A--%20BEGIN%0Aexample%20(a%20b%20c%20:%20Prop)%20(h%20:%20(a%20%E2%88%A7%20b)%20%E2%88%A7%20(c%20%E2%88%A7%20a))%20:%20c%20:=%0Abegin%20destruct_conjunctions%20%3E%3E%20assumption%20end%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">c</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="n">destruct_conjunctions</span> <span class="bp">&gt;&gt;</span> <span class="n">assumption</span> <span class="kd">end</span>
</pre></div>
</div>
</div><p>Note that the reason we can use such code to prove theorems without
compromising the integrity of the formal system is that Lean&#8217;s kernel
always certifies the result. From a foundational point of view, we don&#8217;t
have to worry about the integrity of the code, only the integrity of the
resulting proofs.</p>
</div>
<div class="section" id="overview-of-the-contents">
<h2>1.5. Overview of the contents<a class="headerlink" href="#overview-of-the-contents" title="Permalink to this headline">&#182;</a></h2>
<p>To summarize, we can use Lean in any of the following ways:</p>
<ul class="simple">
<li>as a programming language</li>
<li>as a system for verifying properties of programs</li>
<li>as a system for writing metaprograms, that is, programs that extend
the functionality of Lean itself</li>
</ul>
<p>Chapters <a class="reference external" href="02_Programming_Basics.org::#Programming_Basics">2</a> to
<a class="reference external" href="07_Monads.org::#Monads">7</a> explain how to use Lean as a programming
language. It will be helpful if you have some familiarity with the
syntax and meaning of dependent type theory, for example, as presented
in <em>Theorem Proving in Lean</em> (henceforth <em>TPL</em>). But, if not, it is
likely that you will be able to pick up the details as we proceed.
Similarly, if you are familiar with functional programming, you will be
able to move through the material more quickly, but we will try to keep
the presentation below self contained.</p>
<p><a class="reference external" href="04_Verifying_Properties_of_Programs.org::#Verifying_Properties_of_Programs">Chapter
4</a>
in particular deals with the task of proving things about programs. Once
again, it will be helpful if you are familiar with the use of Lean as an
interactive theorem prover as described in <em>TPL</em>, but if not you are
encouraged to forge ahead and refer back to <em>TPL</em> as necessary.</p>
<p>Finally, <a class="reference external" href="08_Writing_Tactics.org::#Writing_Tactics">Chapter 8</a> and
<a class="reference external" href="09_Writing_Automation.org::#Writing_Automation">Chapter 9</a> deal with
metaprogramming aspects of Lean, and, in particular, writing tactics and
automation.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Programming in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lean-as-a-programming-language">1.1. Lean as a Programming Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">1.2. Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#input-and-output">1.3. Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="#metaprogramming-in-lean">1.4. Metaprogramming in Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overview-of-the-contents">1.5. Overview of the contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="monads.html">2. Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_tactics.html">3. Writing Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_automation.html">4. Writing Automation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="programming_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Leonardo de Moura, and Simon Hudon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/introduction.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>